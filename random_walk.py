# Python code for 2D random walk.import numpyimport pylabimport randomfrom scipy import optimizeimport functions as fndef random_walk(function=fn.eggholder, start_coordinates=[0,0], iterations=100000, bounds=[(-512, 512), (-512, 512)], show_plots=True):    # defining the number of steps    n = iterations    #creating two array for containing x and y coordinate    #of size equals to the number of size and filled up with 0's    x = numpy.zeros(n)    y = numpy.zeros(n)    # set initial coordinates    x[0], y[0] = start_coordinates[0], start_coordinates[1]    # set minimum    minimum = function(start_coordinates)    best_point = start_coordinates    # filling the coordinates with random variables    i = 1    while (i < n):        val = random.randint(1, 4)        if val == 1 and x[i - 1] + 1 < bounds[0][1]: # > 512            x[i] = x[i - 1] + 1            y[i] = y[i - 1]        elif val == 2 and x[i - 1] - 1 > bounds[0][0]: # < -512            x[i] = x[i - 1] - 1            y[i] = y[i - 1]        elif val == 3 and y[i - 1] + 1 < bounds[1][1]: # > 512            x[i] = x[i - 1]            y[i] = y[i - 1] + 1        elif val == 4 and y[i - 1] - 1 > bounds[1][0]: # < -512            x[i] = x[i - 1]            y[i] = y[i - 1] - 1        else:            i = i-1                #check if current point is better than current minimum         curr_point = [x[i],y[i]]        f_curr_point = function(curr_point)        if  f_curr_point <= minimum:            minimum = f_curr_point            best_point = curr_point        #update index in while            i = i+1    result = optimize.OptimizeResult(x=best_point, fun=minimum)    if show_plots:        # plotting stuff:        pylab.title("Random Walk ($n = " + str(n) + "$ steps)")        pylab.plot(x, y,'-',lw=0.5)        #pylab.savefig("rand_walk"+str(n)+".png",bbox_inches="tight",dpi=600)        pylab.show()    return result#random_walk()